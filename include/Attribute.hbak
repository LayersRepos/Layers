#ifndef ATTRIBUTE_H
#define ATTRIBUTE_H

#include <QVariant>

namespace Layers
{
	class AValue : public QObject
	{
		Q_OBJECT

	signals:
		void changed();

	public:
		AValue(QVariant variant);
		AValue(QMap<QString, QVariant> state_variant_map);

		template<typename T>
		T as() const;

		template<typename T>
		T* as(const QString& state) const;

		void copy(AValue* avalue);

		bool is_stateful() const;

		/*!
			Sets the value.

			@param value to set
		*/
		void set(QVariant variant);

		/*!
			Sets the value of the provided state.

			This function only works if the provided state already exists in the data structure.

			@param state to update value of
			@param value pair with state
		*/
		void set(const QString& state, QVariant variant);

		void set_state(const QString& state);

		void set_state_variant_map(const QMap<QString, QVariant>& state_variant_map);

		QList<QString> states() const;

		const char* typeName() const;

		friend QDataStream& operator <<(QDataStream& stream, const AValue& av)
		{
			//stream << *av.m_disabled;
			//stream << av.m_name;
			//stream << av.m_state;

			if (av.m_variant)
			{
				stream << false;
				stream << *av.m_variant;
			}
			else if (av.m_state_variant_map)
			{
				stream << true;
				stream << *av.m_state_variant_map;
			}

			return stream;
		}

		friend QDataStream& operator >>(QDataStream& stream, AValue& av)
		{
			//stream >> *av.m_disabled;
			//stream >> av.m_name;
			//stream >> av.m_state;

			bool is_stateful = false;

			stream >> is_stateful;

			if (!is_stateful)
			{
				av.m_variant = new QVariant;

				stream >> *av.m_variant;
			}
			else
			{
				av.m_state_variant_map = new QMap<QString, QVariant>;

				stream >> *av.m_state_variant_map;
			}

			return stream;
		}

	private:
		QVariant* m_variant{ nullptr };
		QMap<QString, QVariant>* m_state_variant_map{ nullptr };

		QString m_state{ "" };
	};

	struct AttributeLayoutItem : public QObject {};

	/*!
		Pure abstract base class for Layers attributes.

		Implementers of the Attribute class will need to define the value() function since
		this class does not implement the representation of the attribute value(s).

		The functions name(), parent_themeable(), and set_parent_themeable() are defined by
		this class as they are not expected to be different between subclasses.
	*/
	class Attribute : public AttributeLayoutItem
	{
		Q_OBJECT

	signals:
		void value_changed();

	public:
		/*!
			Constructor for the Attribute base class.

			Subclasses are to call this constructor passing along an attribute name string.
		*/
		Attribute(const QString& name, bool disabled = false);
		Attribute(const QString& name, QVariant variant, bool disabled = false);
		Attribute(const QString& name, QMap<QString, QVariant> state_variant_map, bool disabled = false);

		/*!
			Checks if the provided state already exists in the data structure.

			@param state to check
			@returns True if state exists, false if not
		*/
		bool contains_state(const QString& state) const;

		void copy_value_from(const Attribute& attr);

		bool disabled() const;

		/*!
			Returns the name of the attribute.

			@returns Name of attribute
		*/
		QString& name();

		void get_value_from(Attribute& attr);

		bool is_stateful() const;

		void set_disabled(bool disabled = true);

		/*!
			Sets the current state of the attribute.

			@param state to mark as the current attribute state
		*/
		void set_state(const QString& state);

		/*!
			Returns the current state of the attribute.

			@returns Current state of attribute
		*/
		QString state() const;

		/*!
			Returns list of all the attribute's states.

			@returns List of attribute's states
		*/
		QList<QString> states() const;

		const char* typeName() const;

		AValue* value() const;

		friend QDataStream& operator <<(QDataStream& stream, const Attribute& a)
		{
			stream << *a.m_disabled;
			stream << a.m_name;
			//stream << a.m_state;
			stream << *a.m_value;

			//if (a.m_value)
			//{
			//	stream << false;
			//	stream << *a.m_value;
			//}
			//else if (a.m_values)
			//{
			//	stream << true;
			//	stream << *a.m_values;
			//}

			return stream;
		}

		friend QDataStream& operator >>(QDataStream& stream, Attribute& a)
		{
			stream >> *a.m_disabled;
			stream >> a.m_name;
			//stream >> a.m_state;
			stream >> *a.m_value;

			//bool is_stateful = false;

			//stream >> is_stateful;

			//if (!is_stateful)
			//{
			//	a.m_value = new QVariant;

			//	stream >> *a.m_value;
			//}
			//else
			//{
			//	a.m_values = new QMap<QString, QVariant>;

			//	stream >> *a.m_values;
			//}

			return stream;
		}

	private:
		bool* m_disabled{ new bool(false) };

		QString m_name{ "" };

		//QString m_state{ "" };

		bool m_owns_value{ true };

		AValue* m_value{ nullptr };
	};

	template<typename T>
	inline T AValue::as() const
	{
		if (m_variant) return m_variant->value<T>();
		else
		{
			return (*m_state_variant_map)[m_state].value<T>();
		}
	}

	template<typename T>
	inline T* AValue::as(const QString& state) const
	{
		if (m_state_variant_map)
		{
			if (m_state_variant_map->contains(state)) return &(*m_state_variant_map)[state].value<T>();
			else
				qDebug() << "WARNING: Failed to obtain attribute value: State does not exist.";
		}
		else
			qDebug() << "WARNING: Failed to obtain attribute value: State provided but Attribute is not stateful.";

		return nullptr;
	}

	class AttributeGroup : public AttributeLayoutItem
	{
	public:
		AttributeGroup(const QString& name, const QMap<QString, Attribute*>& attributes);

		QMap<QString, Attribute*>& attributes();

		bool is_stateful() const;

		QString name() const;

	private:
		QMap<QString, Attribute*> m_attributes;

		QString m_name;
	};
}

#endif // ATTRIBUTE_H